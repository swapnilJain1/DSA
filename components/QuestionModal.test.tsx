import React from 'react';
import { render, screen, fireEvent, waitFor } from '@testing-library/react';
import '@testing-library/jest-dom';
import { describe, it, expect, jest, beforeAll, afterAll } from '@jest/globals';
import QuestionModal from './QuestionModal';

// Mock child components
jest.mock('./CodeEditor', () => () => <div data-testid="code-editor">Code Editor</div>);
jest.mock('../services/geminiService', () => ({
    generateHint: jest.fn(() => Promise.resolve('Mock Hint')),
    generateTestCases: jest.fn(() => Promise.resolve([{ input: '[]', expected: '[]' }])),
    generateEdgeCases: jest.fn(() => Promise.resolve('Edge cases: null input')),
    autoGenerateTitle: jest.fn(() => Promise.resolve('Mock Title')),
    autoGenerateDescription: jest.fn(() => Promise.resolve('Mock Description')),
    findProblemUrl: jest.fn(() => Promise.resolve('http://mock-url.com')),
    analyzeSolution: jest.fn(() => Promise.resolve('O(n) time')),
    expandDescription: jest.fn(() => Promise.resolve('Expanded Description'))
}));

const mockQuestion = {
    id: '1',
    title: 'Test Title',
    url: 'http://example.com',
    difficulty: 'Medium' as const,
    status: 'Solved' as const, 
    topics: [],
    description: 'Test Description',
    notes: '',
    hints: ['Hint 1', 'Hint 2'],
    solutions: [{ id: '1', title: 'Solution 1', code: '', language: 'javascript' }, { id: '2', title: 'Solution 2', code: '', language: 'python' }],
    testCases: [{ input: '[]', expected: '[]' }], 
    timeTaken: 1200,
    lastAttempted: '2023-01-01',
    mistakes: '',
    nextReviewDate: '2023-01-10',
    reviewInterval: 5
};

const defaultProps = {
    isOpen: true,
    onClose: jest.fn(),
    question: mockQuestion,
    onSave: jest.fn(),
    onDelete: jest.fn(),
    onStartTimer: jest.fn(),
    onAddSessionTime: jest.fn(),
    showToast: jest.fn(),
    apiKey: 'test-key',
    liveTime: 1200
};

Element.prototype.scrollIntoView = jest.fn();

describe('QuestionModal', () => {
    beforeAll(() => {
        Object.defineProperty(window, 'innerWidth', { writable: true, configurable: true, value: 1024 });
        window.dispatchEvent(new Event('resize'));
    });

    it('updates local state when parent question prop changes (Timer Sync)', () => {
        const { rerender } = render(<QuestionModal {...defaultProps} />);
        
        // Initial check
        const timeInput = screen.getByDisplayValue('1200');
        expect(timeInput).toBeInTheDocument();

        // Simulate timer saving in parent app, passing new question prop
        const updatedQuestion = { ...mockQuestion, timeTaken: 1205 };
        rerender(<QuestionModal {...defaultProps} question={updatedQuestion} liveTime={1205} />);

        // Should update
        expect(screen.getByDisplayValue('1205')).toBeInTheDocument();
    });

    it('disables AI buttons when context is missing', () => {
        const incompleteQuestion = { ...mockQuestion, title: '', url: '' };
        render(<QuestionModal {...defaultProps} question={incompleteQuestion} />);

        // Search URL button requires title
        const searchBtn = screen.getByTitle(/Enter a title first/i);
        expect(searchBtn).toBeDisabled();

        // Auto-Fill Description requires Title
        const autoFillBtn = screen.getByTitle(/Title is missing/i);
        expect(autoFillBtn).toBeDisabled();
    });

    it('disables Run and Coach buttons if URL is missing (strict validation)', () => {
        const incompleteQuestion = { ...mockQuestion, url: '' };
        render(<QuestionModal {...defaultProps} question={incompleteQuestion} />);

        // Coach Button
        const coachBtn = screen.getByTitle(/Question URL is missing/i);
        expect(coachBtn).toBeDisabled();

        // Run Button
        const runBtn = screen.getByTitle(/Question URL is missing/i);
        expect(runBtn).toBeDisabled();
    });

    it('renders delete solution button and confirms deletion', async () => {
        render(<QuestionModal {...defaultProps} />);
        const deleteBtn = screen.getByTitle('Delete Solution');
        expect(deleteBtn).toBeInTheDocument();
        fireEvent.click(deleteBtn);
        
        expect(screen.getByText('Delete Solution')).toBeInTheDocument(); // Dialog title
        const confirmBtn = screen.getAllByText('Delete')[1];
        fireEvent.click(confirmBtn);
        
        await waitFor(() => {
            expect(screen.queryByText('Delete Solution')).not.toBeInTheDocument();
        });
    });

    it('switches modes in mobile view', () => {
        // Mock mobile width
        Object.defineProperty(window, 'innerWidth', { writable: true, configurable: true, value: 375 });
        window.dispatchEvent(new Event('resize'));

        render(<QuestionModal {...defaultProps} />);
        
        // Default is Reading Mode
        expect(screen.getByText('Problem Statement')).toBeInTheDocument();
        
        // Switch to Code
        fireEvent.click(screen.getByText('Code'));
        
        // Check for run button
        expect(screen.getByTitle(/Run code/i)).toBeInTheDocument();
    });
});