
import React from 'react';
import { render, screen, fireEvent, waitFor } from '@testing-library/react';
import '@testing-library/jest-dom';
import { describe, it, expect, jest, beforeAll } from '@jest/globals';
import QuestionModal from './QuestionModal';
import * as geminiService from '../services/geminiService';

// Mock child components
jest.mock('./CodeEditor', () => () => <div data-testid="code-editor">Code Editor</div>);
jest.mock('./MarkdownView', () => () => <div data-testid="markdown-view">Markdown Content</div>);

// Mock services
jest.mock('../services/geminiService', () => ({
    generateHint: jest.fn(() => Promise.resolve('Mock Hint')),
    generateTestCases: jest.fn(() => Promise.resolve([{ input: '[]', expected: '[]' }])),
    generateEdgeCases: jest.fn(() => Promise.resolve('Edge cases: null input')),
    autoGenerateTitle: jest.fn(() => Promise.resolve('Mock Title')),
    autoGenerateDescription: jest.fn(() => Promise.resolve('Mock Description')),
    findProblemUrl: jest.fn(() => Promise.resolve('http://mock-url.com')),
    analyzeSolution: jest.fn(() => Promise.resolve('O(n) time')),
    expandDescription: jest.fn(() => Promise.resolve('Expanded Description'))
}));

const mockQuestion = {
    id: '1',
    title: 'Test Title',
    url: 'http://example.com',
    difficulty: 'Medium' as const,
    status: 'Solved' as const, 
    topics: [],
    description: 'Test Description',
    notes: '',
    hints: ['Hint 1', 'Hint 2'],
    solutions: [{ id: '1', title: 'Solution 1', code: '', language: 'javascript' }, { id: '2', title: 'Solution 2', code: '', language: 'python' }],
    testCases: [{ input: '[]', expected: '[]' }], 
    timeTaken: 1200,
    lastAttempted: '2023-01-01',
    mistakes: '',
    nextReviewDate: '2023-01-10',
    reviewInterval: 5
};

const defaultProps = {
    isOpen: true,
    onClose: jest.fn(),
    question: mockQuestion,
    onSave: jest.fn(),
    onDelete: jest.fn(),
    onStartTimer: jest.fn(),
    onAddSessionTime: jest.fn(),
    showToast: jest.fn(),
    apiKey: 'test-key',
    liveTime: 1200
};

Element.prototype.scrollIntoView = jest.fn();

describe('QuestionModal', () => {
    beforeAll(() => {
        Object.defineProperty(window, 'innerWidth', { writable: true, configurable: true, value: 1024 });
        window.dispatchEvent(new Event('resize'));
    });

    it('updates local state when parent question prop changes (Timer Sync)', () => {
        const { rerender } = render(<QuestionModal {...defaultProps} />);
        
        // Initial check
        const timeInput = screen.getByDisplayValue('1200');
        expect(timeInput).toBeInTheDocument();

        // Simulate timer saving in parent app, passing new question prop
        const updatedQuestion = { ...mockQuestion, timeTaken: 1205 };
        rerender(<QuestionModal {...defaultProps} question={updatedQuestion} liveTime={1205} />);

        // Should update
        expect(screen.getByDisplayValue('1205')).toBeInTheDocument();
    });

    it('disables AI buttons when context is missing', () => {
        const incompleteQuestion = { ...mockQuestion, title: '', url: '' };
        render(<QuestionModal {...defaultProps} question={incompleteQuestion} />);

        // Search URL button requires title
        const searchBtn = screen.getByTitle(/Enter a title first/i);
        expect(searchBtn).toBeDisabled();

        // Auto-Fill Description requires Title
        const autoFillBtn = screen.getByTitle(/Title is missing/i);
        expect(autoFillBtn).toBeDisabled();
    });

    it('disables Run and Coach buttons if URL is missing (strict validation)', () => {
        const incompleteQuestion = { ...mockQuestion, url: '' };
        render(<QuestionModal {...defaultProps} question={incompleteQuestion} />);

        // Coach Button
        const coachBtn = screen.getByTitle(/Question URL is missing/i);
        expect(coachBtn).toBeDisabled();

        // Run Button
        const runBtn = screen.getByTitle(/Question URL is missing/i);
        expect(runBtn).toBeDisabled();
    });

    it('renders delete solution button and confirms deletion', async () => {
        render(<QuestionModal {...defaultProps} />);
        const deleteBtn = screen.getByTitle('Delete Solution');
        expect(deleteBtn).toBeInTheDocument();
        fireEvent.click(deleteBtn);
        
        expect(screen.getByText('Delete Solution')).toBeInTheDocument(); // Dialog title
        const confirmBtn = screen.getAllByText('Delete')[1];
        fireEvent.click(confirmBtn);
        
        await waitFor(() => {
            expect(screen.queryByText('Delete Solution')).not.toBeInTheDocument();
        });
    });

    it('switches modes in mobile view', () => {
        // Mock mobile width
        Object.defineProperty(window, 'innerWidth', { writable: true, configurable: true, value: 375 });
        window.dispatchEvent(new Event('resize'));

        render(<QuestionModal {...defaultProps} />);
        
        // Default is Reading Mode
        expect(screen.getByText('Problem Statement')).toBeInTheDocument();
        
        // Switch to Code
        fireEvent.click(screen.getByText('Code'));
        
        // Check for run button
        expect(screen.getByTitle(/Run code/i)).toBeInTheDocument();
    });

    // --- New Tests for Editor Behavior ---

    it('defaults to Edit Mode (textarea) when description is empty', () => {
        const emptyDescQuestion = { ...mockQuestion, description: '' };
        render(<QuestionModal {...defaultProps} question={emptyDescQuestion} />);
        
        // Should see textarea placeholder
        expect(screen.getByPlaceholderText('Paste description...')).toBeInTheDocument();
        // Should NOT see MarkdownView
        expect(screen.queryByTestId('markdown-view')).not.toBeInTheDocument();
    });

    it('defaults to Preview Mode (MarkdownView) when description exists', () => {
        render(<QuestionModal {...defaultProps} />);
        
        // Should see MarkdownView
        expect(screen.getByTestId('markdown-view')).toBeInTheDocument();
        // Should NOT see textarea
        expect(screen.queryByPlaceholderText('Paste description...')).not.toBeInTheDocument();
    });

    it('automatically switches to Preview Mode after AI Auto-Fill', async () => {
        const emptyDescQuestion = { ...mockQuestion, description: '' };
        render(<QuestionModal {...defaultProps} question={emptyDescQuestion} />);
        
        // Initial state: Edit Mode
        expect(screen.getByPlaceholderText('Paste description...')).toBeInTheDocument();

        // Click Auto-Fill
        const autoFillBtn = screen.getByText('Auto-Fill');
        fireEvent.click(autoFillBtn);

        // Wait for async generation
        await waitFor(() => {
            expect(geminiService.autoGenerateDescription).toHaveBeenCalled();
        });

        // Should switch to Preview Mode
        await waitFor(() => {
            expect(screen.getByTestId('markdown-view')).toBeInTheDocument();
            expect(screen.queryByPlaceholderText('Paste description...')).not.toBeInTheDocument();
        });
    });

    it('automatically switches to Preview Mode after AI Expand', async () => {
        render(<QuestionModal {...defaultProps} />);
        
        // Enter edit mode first manually (simulated by clicking the container div in real app, here we rely on existing logic)
        // Since we can't easily click the container div in this mocked structure without proper setup, 
        // we'll assume the user is in view mode, but we want to ensure Expand stays/switches to preview.
        // Actually, if we are in view mode, Expand is available. 
        
        const expandBtn = screen.getByText('Expand');
        fireEvent.click(expandBtn);

        await waitFor(() => {
            expect(geminiService.expandDescription).toHaveBeenCalled();
        });

        // Ensure we are in preview mode showing the "Expanded Description"
        // (MarkdownView mock renders static text, but existence proves the mode)
        expect(screen.getByTestId('markdown-view')).toBeInTheDocument();
    });

    it('switches to Preview Mode and scrolls after generating Edge Cases', async () => {
        render(<QuestionModal {...defaultProps} />);
        
        const edgeCaseBtn = screen.getByText('Edge Cases');
        fireEvent.click(edgeCaseBtn);

        await waitFor(() => {
            expect(geminiService.generateEdgeCases).toHaveBeenCalled();
        });

        // Should be in Preview mode
        expect(screen.getByTestId('markdown-view')).toBeInTheDocument();
        expect(screen.queryByPlaceholderText('Paste description...')).not.toBeInTheDocument();

        // Scroll check (scrollIntoView is mocked)
        await waitFor(() => {
            expect(Element.prototype.scrollIntoView).toHaveBeenCalled();
        });
    });
});
